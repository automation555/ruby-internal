= FALSENODE =
Represents the keyword 'false'.

Members:
none

= TRUENODE =
Represents the keyword 'true'.

Members:
none

= NILNODE =
Represents the keyword 'nil'.

Members:
none

= SELF =
Represents the keyword 'self'.

Members:
none

= CALL =
Represents a method call in the form recv.mid(args).

Members:
* recv (node) - the receiver of the method
* mid (id) - the method id
* args (ARRAY node) - the arguments to the method

= FCALL = 
Represents a method call without an explicit receiver that can be determined
at compile-time to be a method call.

Members:
* mid (id) - the method id
* args (ARRAY node) - the arguments to the method

= VCALL =
Represents a local variable or a method call without an explicit receiver, to
be determined at run-time.

Members:
* mid (id) - the name of the variable or method

= SUPER =
Represents the keyword 'super' when used with parens or with arguments.

Members:
* args (ARRAY node) - the arguments to be passed to the base class

= ZSUPER = 
Represents the keyword 'super' when used without parens nor arguments.  The
arguments to the base class method are obtained from the arguments passed to
the current method, which are store in the current frame.

Members:
none

= ATTRASGN = 
Represents attribute assignment in the form recv.mid = args or recv.mid=(args).

Members:
* recv - the receiver of the method
* mid (id) - the id of the attribute, with a trailing '=' sign
* args - (ARRAY node) - the arguments to the method

= LASGN =
Represents local variable assignment.

Members:
* vid (id) - the name of the local variable
* value (node) - the value to assign to the local variable

= LVAR =
Represents local variable retrieval.

Members:
* vid (id) - the name of the local variable to retrieve.

= DASGN =
Represents dynamic local variable assignment.  Dynamic assignment differs from
static assignment in that the slots for static local variables are allocated
when the method is called, wereas slots for dynamic variables are allocated
when the variable is first assigned to.  When searching for the variable,
dynamic assignment searches backward up the stack to see if the variable
exists in any previous block in the current frame; if it does, it assigns to
the slot found in that block, otherwise it creates a new variable slot.  As a
result, dynamic assignment is typically much slower than static assignment.

Members:
* vid (id) - the name of the local variable
* value (node) - the value to assign to the local variable

= DVAR =
Represents dynamic local variable retrieval.

See also DASGN.

Members:
* vid (id) - the name of the local variable to retrieve.

= IASGN =
Represents instance variable assignment.

* vid (id) - the name of the instance variable, with a leading '@' sign
* value (node) - the value to assign to the instance variable

= IVAR =
Represents instance variable retrieval.

* vid (id) - the name of the instance variable to retrieve, with a leading '@' sign

= MASGN =
Represents multiple assignment.

Members:
* head (node) - TODO
* args (node) - TODO
* value (node) - TODO

= OP_ASGN1 =
Represents bracket assignment of the form:
  recv[index] += value or 
  recv[index] ||= value or
  recv[index] &&= value.

The index is obtained from args.body.

The value is obtained from args.head.

In the case of ||=, mid will be 0.  The rhs will be equal to the result of
evaluating args.head if the lhs is false, otherwise the rhs will be equal to
lhs.

In the case of &&=, mid will be 1.  The rhs will be equal to the lhs if lhs is
false, otherwise the rhs will be equal to the result of evaluating args.head.

In all other cases, mid will be the name of the method to call to calculate
value, such that the expression is equivalent to:
  recv[args.body] = recv[args.body].mid(args.head)

In no case does ruby short-circuit the assignment.

Members:
* recv (node) - the receiver of the assignment
* mid (id) - 0, 1, or the name a method to call to calculate the value of the
  rhs
* args (ARGSCAT node) - the arguments to the assigment

= OP_ASGN_OR =
Represents an expression of the form:
  recv ||= value

Ruby will evaluate the expression on the left hand side.  If it is undefined,
nil, or false, then ruby will evaluate the expression on the right hand side
and assign it to recv.  The expression will short-circuit if recv is defined
and true (non-false, non-nil).

Members:
* recv (node) - the receiver of the assignment
* value (node) - the right hand side of the assignment
* aid (id) - if this indicator is nonzero, ruby will check to see if the provided
  expression is defined, otherwise it will assume that the provided expression
  is defined.

= OP_ASGN_AND =
Represents an expression of the form:
  recv &&= value

Ruby will evaluate the expression left hand side of the assignment; if it is
true, then it will assign the result of the expression on the right hand side
to the receiver on the left hand side.

Members:
* head (node) - an expression representing the left hand side of the
  assignment
* value (node) - an expression representing the assignment that should be
  performed if the left hand side is true

= DEFINED =
Represents an expression using the 'defined?' keyword.

The result is either nil or a string describing the expression.

Members:
* head (node) - the expression to inspect

= CONST =
Represents a constant lookup in the current class.

The current class is the class in which the containing scope was defined.

Members:
* vid (id) - the name of the constant to look up

= COLON3 =
Represents a constant lookup or method call in class Object.

This expression has the form:
  ::mid

Members:
* mid (id) - the name of the method or constant to call/look up

= COLON2 =
Represents a constant lookup in a particular class.

This expressoin has the form:
  klass::mid

Where klass is the result of evaluating the expression in the head member.

Members:
* head (node) - an expression specifying the class in which to do the lookup
* mid (id) - the name of the method or constant to call/look up

= CVAR =
Represents a class variable retrieval.

Members:
* vid (id) - the name of the class variable, with two leading '@' characters.

= CVASGN =
Represents class variable assignment.

Members:
* vid (id) - the name of the class variable to assign
* value (node) - an expression whose result is the new value of the class
  variable

= GASGN =
Represents global variable assignment.

Members:
* vid (id) - the name of the global variable, with a leading '$' character.
* value (node) - an expression whose result is the new value of the global
  variable

= GVAR =
Represents global variable retrieval.

Members:
* vid (id) the name of the global variable to retrieve, with a leading '$'
  character.

= LIT =
Represents a literal object.

The result of the expression is the object contained in this node.

Members:
* lit (object) - the object

= RETURN =
Represents the 'return' keyword.

Evaluation of this node results in a return from the current method.  If no
argument is supplied, returns nil, otherwise returns the result of the
supplied expression.

Members:
* stts (node or 0) - an expression representing the value to return

= NEWLINE =
Represents the termination of a line.  This is used for calling event hooks
when a new line of code is reached.

Members:
* next (node) - the expression on the next line

= BLOCK =
Represents a block of code (a succession of multiple expressions).

A single block node can hold two expressions: one expression to be evaluated
and second expression, which may be another BLOCK.

The first node in the block may be of type ARGS, in which case it represents
the arguments to the current method.

The second node in the block may be of type BLOCK_ARG, in which case it
represents an explicit block argument.

The result of the block is the last expression evaluated.

Members:
* head (node) - the first expression in the block of code
* next (node) - the second expression in the block of code

= SCOPE =
Represents a lexical scope.

A new scope is created when a method is invoked.  The scope node holds
information about local variables and arguments to the method.

The first two variables in the local variable table are the implicit variables
$_ and $~.

The next variables listed in the local variable table are the arguments to
the method.  More information about the arguments to the method are stored in
the ARGS node, which will either be the first node in the scope or the first
node in the BLOCK held by the scope.

Members:
* rval (node) - holds information about which class(es) to search for
  constants in this scope
* tbl (pointer to array of ID) - the names of the local variables
* next - the first expression in the scope

= ARGS =
Represents the arguments to a method.

Members:
* cnt (int) - the number of required arguments
* rest (node) - an assignment node to assign the rest arg, if it is present
* opt (BLOCK node) - a list of assignment nodes to assign default values to
  the optional arguments if no argument is specified

= BLOCK_ARG =
Represents a block argument.

Members:
* cnt - the index into the local variable table of the name of the block
  argument, not including the implicit variables.

= SCLASS =
Represents the body of a singleton class definition, e.g.:
  class << recv
    body
  end

The class definition is evaluated in a new lexical scope.

Members:
* recv (node) - the object whose singleton class is to be modified
* body (node) - the body of the class definition

= DEFS =
Represents a singleton method definition, e.g.:
  def recv.mid
    defn
  end

Members:
* recv (node) - the object to whose singleton class the new method is to be
  added
* mid (id) - the name of the method
* defn - the body of the method

= DEFN =
Represents a method definition, e.g.:
  def mid
    defn
  end

Members:
* mid (id) - the name of the method
* defn - the body of the method

= UNTIL =
Represents a loop constructed with the 'until' keyword, e.g.:
  until cond do
    body
  end

Members:
* cond (node) - a condition to terminate the loop when it becomes true
* body (node) - the body of the loop

= WHILE =
Represents a loop constructed with the 'while' keyword, e.g.:
  while cond do
    body
  end

Members:
* cond (node) - a condition to terminate the loop when it becomes false
* body (node) - the body of the loop

= YIELD =
Represents the 'yield' keyword.

When evaluated, causes control of the program to be transferred to the block
passed by the calling scope.

Members:
* head (node) - the value to yield
* state (int) - if nonzero, splats the value before yielding

= FOR =
Represents a loop constructed with the 'for' keyword, e.g.:
  for var in iter do
    body
  end

This is equivalent to:
  iter.each do |*args|
    assign args to var
    body
  end

Except that a new block is not created.

Members:
* iter (node) - the sequence over which to iterate
* var (node) - an assignment node which assigns the next value in the sequence
  to a variable, which may or may not be local.  May also be a multiple
  assignment.
* body (node) - the body of the loop

= NEXT =
Represents the 'next' keyword.

Causes control to be transferred to the end of the loop, causing the next
value in the sequence to be retrieved.

Members:
none

= REDO =
Represents the 'redo' keyword.

Causes control to be transferred to the beginning of the loop.  The loop
assignment is not repeated.

Members:
none

= BREAK =
Represents the 'break' keyword.

Causes control to be transferred out of the current loop.

Members:
* stts (node) - the value to be used as the "return" value of the loop, 0 if
  nil is to be used.

= ITER =
Represents an iteration loop, e.g.:
  iter do |*args|
    assign args to var
    body
  end

A new block is created so that dynamic variables created inside the loop do
not persist once the loop has terminated.

Members:
* iter (node) - an expression which calls the desired iteration method,
  usually recv.each
* var (node) - an assignment node which assigns the next value in the sequence
  to a variable, which may or may not be local.  May also be a multiple
  assignment.
* body (node) - the body of the loop

= BEGIN =
= ENSURE =
= RESCUE =
= IF =
= CASE =
= WHEN =
= NOT =
= OR =
= AND =
= STR =
= DSTR =
= XSTR =
= DXSTR =
= EVSTR =
= ARRAY =
= ZARRAY =
= TO_ARY =
= HASH =
= DOT2 =
= DOT3 =
= SPLAT =
= SVALUE =
= ARGSCAT =
= NTH_REF =
= MATCH =
= MATCH2 =
= MATCH3 =

