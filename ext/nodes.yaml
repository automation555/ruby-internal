ALIAS:
  desc: |
  members:
    1st:
    2nd:

ALLOCA:
  desc: |
  members:
    lit:

AND:
  desc: |
    Represents a logical 'and' of the form\:
      first && second
    The expression will short-circuit and yield the result of the left
    hand side if it is false or nil, else it will evaluate the right
    hand side and use it as the result of the expression.
  members:
    second:
      type: node
      desc: the expression on the right hand side
    first:
      type: node
      desc: the expression on the left hand side

ARGSCAT:
  desc: |
    Represents the concatenation of a list of arguments and a splatted
    value, e.g.\:
      a, b, *value
    Evaluates head and to create an array.  Evaluates body and performs
    a splat operation on the result to create another array (see SPLAT).
    Concatenates the the second array onto the end of the first to
    produce the result.
  members:
    head:
      type: ARRAY node
      desc: a list of fixed arguments
    body:
      type: node
      desc: |
        the last argument, which will be splatted onto the end of the
        fixed arguments

ARGSPUSH:
  desc: |
  members:
    head:
    body:

ARRAY:
  desc: |
    Represents an array of elements.  Evaluation of this node creates a
    new Array by evalating the given expressions and placing them into
    the array.
  members:
    alen:
    head:
      type: node
      desc: the first element of the array
    next:
      type: node or 0
      desc: the tail of the array

ARGS:
  desc: |
    Represents the arguments to a method.
  members:
    rest:
      type: node
      desc: an assignment node to assign the rest arg, if it is present
    opt:
      type: BLOCK node
      desc: |
        a list of assignment nodes to assign default values to the
        optional arguments if no argument is specified
    cnt:
      type: int
      desc: the number of required arguments

ATTRASGN:
  desc: |
    Represents attribute assignment in the form\:
      recv.mid = args
    or\:
      recv.mid=(args).
  members:
    recv:
      desc: the receiver of the method
    args:
      type: ARRAY node
      desc: the arguments to the method
    mid:
      type: id
      desc: the id of the attribute, with a trailing '=' sign
  version: '[180, oo)'

ATTRSET:
  desc: |
  members:
    vid:

BACK_REF:
  desc: |
  members:
    nth:
    cnt:

BEGIN:
  desc: |
  members:
    body:

BLOCK:
  desc: |
    Represents a block of code (a succession of multiple expressions).
    A single block node can hold two expressions\: one expression to be
    evaluated and second expression, which may be another BLOCK.
    The first node in the block may be of type ARGS, in which case it
    represents the arguments to the current method.
    The second node in the block may be of type BLOCK_ARG, in which case
    it represents an explicit block argument.
    The result of the block is the last expression evaluated.
  members:
    head:
      type: node
      desc: the first expression in the block of code
    next:
      type: node
      desc: the second expression in the block of code

BLOCK_ARG:
  desc: |
    Represents a block argument.  argument, not including the implicit
    variables.
  members:
    cnt:
      desc: the index into the local variable table of the name of the block

BLOCK_PASS:
  desc: |
  members:
    body:
    iter:

BMETHOD:
  desc: |
  members:
    cval:

BREAK:
  desc: |
    Represents the 'break' keyword.  Causes control to be transferred
    out of the current loop.
  members:
    stts:
      type: node
      desc: the value to be used as the "return" value of the loop, 0 if  nil is to be used.

CFUNC:
  desc: |
  members:
    cfnc:
    tval:
    argc:

CDECL:
  desc: |
  members:
    value:
    vid:

CLASS:
  desc: |
  members:
    super:
    cpath:
    body:
  version: '[180, oo)'

COLON2:
  desc: |
    Represents a constant lookup in a particular class.  This expression
    has the form\:
      klass::mid
    Where klass is the result of evaluating the expression in the head member.
  members:
    head:
      type: node
      desc: an expression specifying the class in which to do the lookup
    mid:
      type: id
      desc: the name of the method or constant to call/look up

COLON3:
  desc: |
    Represents a constant lookup or method call in class Object.  This
    expression has the form\:
      ::mid
  members:
    mid:
      type: id
      desc: the name of the method or constant to call/look up

CONST:
  desc: |
    Represents a constant lookup in the current class.  The current
    class is the class in which the containing scope was defined.
  members:
    vid:
      type: id
      desc: the name of the constant to look up

CREF:
  desc: |
  members:
    clss:
    next:
    body:
  version: (0, 190)

CVAR:
  desc: |
    Represents a class variable retrieval.
  members:
    vid:
      type: id
      desc: the name of the class variable, with two leading '@' characters.

CVASGN:
  desc: |
    Represents class variable assignment.
  members:
    value:
      type: node
      desc: |
        an expression whose result is the new value of the class
        variable
    vid:
      type: id
      desc: the name of the class variable to assign

DASGN:
  desc: |
    Represents dynamic local variable assignment.  Dynamic assignment
    differs from static assignment in that the slots for static local
    variables are allocated when the method is called, wereas slots for
    dynamic variables are allocated when the variable is first assigned
    to.  When searching for the variable, dynamic assignment searches
    backward up the stack to see if the variable exists in any previous
    block in the current frame; if it does, it assigns to the slot found
    in that block, otherwise it creates a new variable slot.  As a
    result, dynamic assignment is typically much slower than static
    assignment.
  members:
    value:
      type: node
      desc: the value to assign to the local variable
    vid:
      type: id
      desc: the name of the local variable

DASGN_CURR:
  desc: |
  members:
    value:
    vid:

DEFINED:
  desc: |
    Represents an expression using the 'defined?' keyword.  The result
    is either nil or a string describing the expression.
  members:
    head:
      type: node
      desc: the expression to inspect

DEFN:
  desc: |
    Represents a method definition, e.g.:
      def mid
        defn
      end
  members:
    defn:
    mid:
      type: id
      desc: the name of the method* defn the body of the method
    noex:

DEFS:
  desc: |
    Represents a singleton method definition, e.g.:
      def recv.mid
        defn
      end
  members:
    defn:
    recv:
      type: node
      desc: the object to whose singleton class the new method is to be  added
    mid:
      type: id
      desc: the name of the method* defn the body of the method

DMETHOD:
  desc: |
  members:
    cval:
  version: (0, 190)

DOT2:
  desc: |
    Represents a range created with the form\:
      beg..end
    Creates a range which does not exclude the range end.
  members:
    beg:
      type: node
      desc: the beginning of the range
    end:
      type: node
      desc: the end of the range
    state:

DOT3:
  desc: |
    Represents a range created with the form\:
      beg...end
    Creates a range which excludes the range end.
  members:
    beg:
      type: node
      desc: the beginning of the range
    end:
      type: node
      desc: the end of the range
    state:

DREGX:
  desc: |
  members:
    lit:
    next:
    cflag:

DREGX_ONCE:
  desc: |
  members:
    lit:
    next:
    cflag:

DSTR:
  desc: |
    Represents a string object with interpolation.  The node is
    evaluated by duplicating the string stored in the 'lit' element,
    then iterating over the nodes stored in the 'next' element.  Each
    node found should evalate to an string, and each resulting string is
    appended onto the original string.  Interpolation is represented
    with the EVSTR node.
  members:
    lit:
      type: object
      desc: a string
    next:
      type: ARRAY node
      desc: a list of expressions to be appended onto the string

DSYM:
  desc: |
  members:
    lit:
    next:
  version: '[180, oo)'

DVAR:
  desc: |
    Represents dynamic local variable retrieval.  See also DASGN.
  members:
    vid:
      type: id
      desc: the name of the local variable to retrieve.

DXSTR:
  desc: |
    Represents a string object with interpolation inside backticks,
    e.g.\:
      `lit#{next}`

    The node is evaluated by duplicating the string stored in the 'lit'
    element, then iterating over the nodes stored in the 'next' element.
    Each node found should evalate to an string, and each resulting
    string is appended onto the original string.

    The resulting string is executed in a subshell and the output from
    its stdout stored in a string, which becomes the result of the
    expression.  Interpolation is represented with the EVSTR node.

  members:
    lit:
      type: object
      desc: a string
    next:
      type: ARRAY node
      desc: a list of expressions to be appended onto the string

ENSURE:
  desc: |
  members:
    head:
    ensr:

EVSTR:
  desc: |
    Represents a single string interpolation.
    Evaluates the given expression and converts its result to a string with #to_s.
  members:
    body:
      type: node
      desc: an expression to evaluate
  version: '(0, 180)'

EVSTR(2):
  desc: |
  members:
    lit:
  version: '[180, oo)'

'FALSE':
  desc: |
    Represents the keyword 'false'.
  members:

FBODY:
  desc: |
  members:
    orig:
    mid:
    head:
  version: (0, 190)

FBODY(2):
  desc: |
  members:
    body:
    oid:
    cnt:
  version: '[190, oo)'

FCALL:
  desc: |
  members:
    args:
    mid:

FLIP2:
  desc: |
  members:
    cnt:
    beg:
    end:

FLIP3:
  desc: |
  members:
    cnt:
    beg:
    end:

FOR:
  desc: |
    Represents a loop constructed with the 'for' keyword, e.g.\:
      for var in iter do
        body
      end

    This is equivalent to\:
      iter.each do |*args|
      assign args to var
      body
    end

    Except that a new block is not created.

  members:
    body:
      type: node
      desc: the body of the loop
    iter:
      type: node
      desc: the sequence over which to iterate
    var:
      type: node
      desc: |
        an assignment node which assigns the next value in the sequence
        to a variable, which may or may not be local.  May also be a
        multiple assignment.

GASGN:
  desc: |
    Represents global variable assignment.
  members:
    value:
      type: node
      desc: an expression whose result is the new value of the global variable
    vid:
      type: id
      desc: the name of the global variable, with a leading '$' character.
    entry:

GVAR:
  desc: |
    Represents global variable retrieval.
  members:
    vid:
      type: id
      desc: the name of the global variable to retrieve, with a leading '$'
    entry:

HASH:
  desc: |
    Represents a hash table.  Evaluation of this node creates a new Hash
    by evaluating the given expressions and placing them into the table.
  members:
    head:
      type: ARRAY node
      desc: an array of successive keys and values

IASGN:
  desc: |
    Represents instance variable assignment.
  members:
    value:
      type: node
      desc: the value to assign to the instance variable
    vid:
      type: id
      desc: the name of the instance variable, with a leading '@' sign

IF:
  desc: |
  members:
    body:
    else:
    cond:

IFUNC:
  desc: |
  members:
    cfnc:
    tval:
    argc:

ITER:
  desc: |
    Represents an iteration loop, e.g.\:
      iter do |*args|
        assign args to var
        body
      end
    A new block is created so that dynamic variables created inside the
    loop do not persist once the loop has terminated.
  members:
    body:
      type: node
      desc: the body of the loop
    iter:
      type: node
      desc: an expression which calls the desired iteration method,  usually recv.each
    var:
      type: node
      desc: |
        an assignment node which assigns the next value in the sequence
        to a variable, which may or may not be local.  May also be a
        multiple assignment.

LASGN:
  desc: |
    Represents local variable assignment.
  members:
    value:
      type: node
      desc: the value to assign to the local variable
    vid:
      type: id
      desc: the name of the local variable
    cnt:

LIT:
  desc: |
    Represents a literal object.  The result of the expression is the
    object contained in this node.
  members:
    lit:
      type: object
      desc: the object

LVAR:
  desc: |
    Represents local variable retrieval.
  members:
    vid:
      type: id
      desc: the name of the local variable to retrieve.
    cnt:

MASGN:
  desc: |
    Represents multiple assignment.
  members:
    args:
      type: node
      desc: TODO
    head:
      type: node
      desc: TODO
    value:
      type: node
      desc: TODO

MATCH:
  desc: |
  members:
    head:

MATCH2:
  desc: |
  members:
    recv:
    value:

MATCH3:
  desc: |
  members:
    recv:
    value:

MEMO:
  desc: |
  members:
    lit:
    tval:

METHOD:
  desc: |
  members:
    noex:
    body:
  version: (0, 190)

METHOD(2):
  desc: |
  members:
    body:
    clss:
    noex:
  version: '[190, oo)'

MODULE:
  desc: |
  members:
    cpath:
    body:
  version: '[180, oo)'

OP_ASGN_AND:
  desc: |
    Represents an expression of the form\:
      recv &&= value
    Ruby will evaluate the expression left hand side of the assignment; if it is
    true, then it will assign the result of the expression on the right hand side
    to the receiver on the left hand side.
  members:
    head:
      type: node
      desc: an expression representing the left hand side of the  assignment
    value:
      type: node
      desc: |
        an expression representing the assignment that should be
        performed if the left hand side is true

OP_ASGN_OR:
  desc: |
    Represents an expression of the form\:
      recv ||= value
    Ruby will evaluate the expression on the left hand side.  If it is
    undefined, nil, or false, then ruby will evaluate the expression on
    the right hand side and assign it to recv.  The expression will
    short-circuit if recv is defined and true (non-false, non-nil).
  members:
    aid:
      type: id
      desc: |
        if this indicator is nonzero, ruby will check to see if the
        provided expression is defined, otherwise it will assume that
        the provided expression is defined.
    value:
      type: node
      desc: the right hand side of the assignment
    recv:
      type: node
      desc: the receiver of the assignment

OR:
  desc: |
    Represents a logical 'or' of the form\:
      first || second
    The expression will short-circuit and yield the result of the left
    hand side if it is true, else it will evaluate the right hand side
    and use it as the result of the expression.
  members:
    second:
      type: node
      desc: the expression on the right hand side
    first:
      type: node
      desc: the expression on the left hand side

POSTEXE:
  desc: |
  members:

REGX:
  desc: |
  members:
    cflag:
  version: '[170, oo)'

RESBODY:
  desc: |
  members:
    head:
    body:
    args:

RESCUE:
  desc: |
  members:
    head:
    resq:
    else:

RESTARY:
  desc: |
  members:
    head:
  version: '[170, oo)'

RETRY:
  desc: |
  members:

RETURN:
  desc: |
    Represents the 'return' keyword.  Evaluation of this node results in
    a return from the current method.  If no argument is supplied,
    returns nil, otherwise returns the result of the supplied
    expression.
  members:
    stts:
      type: node or 0
      desc: an expression representing the value to return

REXPAND:
  desc: |
  members:
    head:
  version: '[170, oo)'

SCLASS:
  desc: |
    Represents the body of a singleton class definition, e.g.:
      class << recv
        body
      end
    The class definition is evaluated in a new lexical scope.

  members:
    body:
      type: node
      desc: the body of the class definition
    recv:
      type: node
      desc: the object whose singleton class is to be modified

SCOPE:
  desc: |
    Represents a lexical scope.
    A new scope is created when a method is invoked.  The scope node
    holds information about local variables and arguments to the method.
    The first two variables in the local variable table are the implicit
    variables $_ and $~.
    The next variables listed in the local variable table are the
    arguments to the method.  More information about the arguments to
    the method are stored in the ARGS node, which will either be the
    first node in the scope or the first node in the BLOCK held by the
    scope.
  members:
    tbl:
      type: pointer to array of ID
      desc: |
        the names of the local variables* next the first expression in
        the scope
    rval:
      type: node
      desc: |
        holds information about which class(es) to search for  constants
        in this scope
    next:

SELF:
  desc: |
    Represents the keyword 'self'.
  members:

SPLAT:
  desc: |
    Represents the splat (*) operation as an rvalue, e.g.\:
      *head
    If the argument is an array, returns self.
    If the argument is nil, returns [nil].
    If the argument is any other value, returns the result of calling #to_a on the
    argument.
  members:
    head:
      type: node
      desc: the argument to splat.
  version: '[180, oo)'

STR:
  desc: |
    Represents a string object.  Duplicates the string stored in the
    node.
  members:
    lit:
      type: object
      desc: the string to be duplicated

SUPER:
  desc: |
    Represents the keyword 'super' when used with parens or with arguments.
  members:
    args:
      type: ARRAY node
      desc: the arguments to be passed to the base class
     
SVALUE:
  desc: |
    Represents the collection of multiple values of the right hand side
    of an assignment into a single value, for use in single assignment,
    e.g.:
      lhs = a, b, c
    The argument to this node is an Array.
    If it is length 0, returns nil.
    If it is length 1, returns the first element in the array.
    Otherwise, returns the array.
  members:
    head:
      type: node
      desc: an expression which returns an Array.
  version: '[180, 190)'

'TRUE':
  desc: |
    Represents the keyword 'true'.
  members:

UNDEF:
  desc: |
  members:
    head:
  version: '(0, 185)'

UNDEF:
  desc: |
  members:
    body:
  version: '[185, oo)'

UNTIL:
  desc: |
    Represents a loop constructed with the 'until' keyword, e.g.:
      until cond do
        body
      end
  members:
    body:
      type: node
      desc: the body of the loop
    cond:
      type: node
      desc: a condition to terminate the loop when it becomes true
    state:

VCALL:
  desc: |
    Represents a local variable or a method call without an explicit
    receiver, to be determined at run-time.
  members:
    mid:
      type: id
      desc: the name of the variable or method

WHILE:
  desc: |
    Represents a loop constructed with the 'while' keyword, e.g.\:
      while cond do
        body
      end
  members:
    body:
      type: node
      desc: the body of the loop
    cond:
      type: node
      desc: a condition to terminate the loop when it becomes false
    state:

XSTR:
  desc: |
    Represents a string object inside backticks, e.g.\:
      `lit`
    The given string is executed in a subshell and the output from its
    stdout stored in a string.
  members:
    lit:
      type: object
      desc: the string to be executed

YIELD:
  desc: |
    Represents the 'yield' keyword.  When evaluated, causes control of
    the program to be transferred to the block passed by the calling
    scope.
  members:
    head:
      type: node
      desc: the value to yield
    state:
      type: int
      desc: if nonzero, splats the value before yielding

ZSUPER:
  desc: |
    Represents the keyword 'super' when used without parens nor
    arguments.  The arguments to the base class method are obtained from
    the arguments passed to the current method, which are store in the
    current frame.
  members:

TO_ARY:
  desc: |
    Represents a conversion from one object type to an array type.
    Evaluation of this node converts its argument to an array by calling
    \#to_ary on the argument.
  members:
    head:
      type: node
      desc: the object to convert to an array
  version: '[180, oo)'

NEWLINE:
  desc: |
    Represents the termination of a line.  This is used for calling
    event hooks when a new line of code is reached.
  members:
    next:
      type: node
      desc: the expression on the next line

NOT:
  desc: |
    Represents a logical negation.
  members:
    body:
      type: node
      desc: the value to negate.
  version: (0, 190)

NTH_REF:
  desc: |
  members:
    nth:
    cnt:

CASE:
  desc: |
  members:
    head:
    body:
    next:

WHEN:
  desc: |
  members:
    head:
    body:
    next:

REDO:
  desc: |
    Represents the 'redo' keyword.  Causes control to be transferred to
    the beginning of the loop.  The loop assignment is not repeated.
  members:

NEXT:
  desc: |
    Represents the 'next' keyword.
    Causes control to be transferred to the end of the loop, causing the
    next value in the sequence to be retrieved.
  members:
    stts:

OP_ASGN1:
  desc: |
    Represents bracket assignment of the form\:
      recv[index] += value or 
      recv[index] ||= value or
      recv[index] &&= value.

    The index is obtained from args.body.

    The value is obtained from args.head.

    In the case of ||=, mid will be 0.  The rhs will be equal to the
    result of evaluating args.head if the lhs is false, otherwise the
    rhs will be equal to lhs.

    In the case of &&=, mid will be 1.  The rhs will be equal to the lhs
    if lhs is false, otherwise the rhs will be equal to the result of
    evaluating args.head.  In all other cases, mid will be the name of
    the method to call to calculate value, such that the expression is
    equivalent to\:
      recv[args.body] = recv[args.body].mid(args.head)

    In no case does ruby short-circuit the assignment.

  members:
    args:
      type: ARGSCAT node
      desc: the arguments to the assigment
    mid:
      type: id
      desc: |
        0, 1, or the name a method to call to calculate the value of the
        rhs
    recv:
      type: node
      desc: the receiver of the assignment

OP_ASGN2:
  desc: |
  members:
    vid:
    recv:
    value:

OPT_N:
  desc: |
  members:
    body:

IVAR:
  desc: |
    Represents instance variable retrieval.
  members:
    vid:
      type: id
      desc: |
        the name of the instance variable to retrieve, with a leading
        '@' sign

CALL:
  desc: |
    Represents a method call in the form recv.mid(args).
  members:
    args:
      type: ARRAY node
      desc: the arguments to the method
    mid:
      type: id
      desc: the method id
    recv:
      type: node
      desc: the receiver of the method

NIL:
  desc: |
    Represents the keyword 'nil'.
  members:

ZARRAY:
  desc: |
    Represents an array of zero elements.  Evalation of this node
    creates a new array of length zero.
  members:

