ALIAS:
  doc: |
    Represents an alias expression of the form:
      alias 1st 2nd
    where 2nd is the name of an existing method and 1st is the name of
    its new alias.
  members:
    1st: the name of an exiting method
    2nd: the name of its new alias

ALLOCA:
  doc: |
    A node used for temporary allocation of memory on platforms that do
    not support alloca.

    It should never be evaluated as an expression.

  members:
    cfunc:
      doc: a pointer to the allocated memory
    node:
      doc: a pointer to the previously allocated temporary node
    cnt:
      doc: the number of bytes allocated

AND:
  doc: |
    Represents a logical 'and' of the form:
      first && second
    The expression will short-circuit and yield the result of the left
    hand side if it is false or nil, else it will evaluate the right
    hand side and use it as the result of the expression.
  members:
    2nd:
      type: node
      doc: the expression on the right hand side
    1st:
      type: node
      doc: the expression on the left hand side

ARGSCAT:
  doc: |
    Represents the concatenation of a list of arguments and a splatted
    value, e.g.:
      a, b, *value
    Evaluates head to create an array.  Evaluates body and performs a
    splat operation on the result to create another array (see SPLAT).
    Concatenates the the second array onto the end of the first to
    produce the result.
  members:
    head:
      type: ARRAY node
      doc: a list of fixed arguments
    body:
      type: node
      doc: |
        the last argument, which will be splatted onto the end of the
        fixed arguments

ARGSPUSH:
  doc: |
    Represents the splat portion of the index in an expression:
      obj[arg, arg, *head] = body
    Evaluates head to create an array.  Evaluates body and pushes the
    result onto the end of the array, which will then be used to form
    the arguments of the method call.
  members:
    head: a splat expression
    body: the rhs of the assignment

ARRAY:
  doc: |
    Represents an array of elements.  Evaluation of this node creates a
    new Array by evalating the given expressions and placing them into
    the array.
  members:
    alen:
    head:
      type: node
      doc: the first element of the array
    next:
      type: node or 0
      doc: the tail of the array

ARGS:
  doc: |
    Represents the arguments to a method.
  members:
    rest:
      type: node
      doc: an assignment node to assign the rest arg, if it is present
    opt:
      type: BLOCK node
      doc: |
        a list of assignment nodes to assign default values to the
        optional arguments if no argument is specified
    cnt:
      type: int
      doc: the number of required arguments

ATTRASGN:
  doc: |
    Represents attribute assignment in the form:
      recv.mid = args
    or:
      recv.mid=(args).
  members:
    recv:
      doc: the receiver of the method
    args:
      type: ARRAY node
      doc: the arguments to the method
    mid:
      type: id
      doc: the id of the attribute, with a trailing '=' sign
  version: '[180, oo)'

ATTRSET:
  doc: |
    A placeholder for an attribute writer method, which can added to a
    class by using attr_writer:
      attr_writer :attribute
    Its reader counterpart is IVAR.
  members:
    vid:
      doc: the name of the attribute, with a leading '@' sign

BACK_REF:
  doc: |
    Represents one of the regex back reference variables:
    * $& - last match
    * $` - pre
    * $' - post
    * $+ - last
  members:
    nth:
      doc: |
        the integer representation of the character of the variable to
        reference, one of '&', '`', '\'', or '+'
      #'
    cnt:
      doc: |
        the index into the local variable table where the match data is
        stored

BEGIN:
  doc: |
   Represents a begin/end block.

   TODO: Need an example
  members:
    body: the body of code inside the block

BLOCK:
  doc: |
    Represents a block of code (a succession of multiple expressions).
    A single block node can hold two expressions: one expression to be
    evaluated and second expression, which may be another BLOCK.
    The first node in the block may be of type ARGS, in which case it
    represents the arguments to the current method.
    The second node in the block may be of type BLOCK_ARG, in which case
    it represents an explicit block argument.
    The result of the block is the last expression evaluated.
  members:
    head:
      type: node
      doc: the first expression in the block of code
    next:
      type: node
      doc: the second expression in the block of code

BLOCK_ARG:
  doc: |
    Represents a block argument in a method definition, e.g.:
      def foo(&arg)
      end

  members:
    cnt:
      doc: |
        the index into the local variable table of the name of the block
        argument, not including the implicit variables.

BLOCK_PASS:
  doc: |
    Represents an object being passed to a method as a block, e.g.:
      foo(&bar)

    The body node is first evaluates to get an object, then #to_proc to
    convert it into a proc if necessary.  The iter node is then
    evaluated to call a method, passing the proc as a block parameter to
    the method.

  members:
    body:
      type: node
      doc: the object to pass as a block
    iter:
      type: node
      doc: an expression which calls a method

BMETHOD:
  doc: |
    A placeholder for a method defined using define_method, e.g.:
      define_method(:foo) {
        ...
      }

    See also DMETHOD.

  members:
    cval:
      doc: |
        the Proc object passed to define_method, which contains the body
        of the method
  version: (0, 190)

BREAK:
  doc: |
    Represents the 'break' keyword.  Causes control to be transferred
    out of the current loop.

  members:
    stts:
      type: node
      doc: the value to be used as the "return" value of the loop, 0 if  nil is to be used.

CALL:
  doc: |
    Represents a method call in the form recv.mid(args).
  members:
    args:
      type: ARRAY node
      doc: the arguments to the method
    mid:
      type: id
      doc: the method id
    recv:
      type: node
      doc: the receiver of the method

CASE:
  doc: |
    Represents the value portion of a case/end block, e.g.:
      case head
      body
      end
      next
  members:
    head:
      doc: the value to select on
    body:
      type: WHEN node
      doc: |
        a linked list of nodes, each node representing a when
        conditional
    next:
      the next node to evaluate in the syntax tree

CFUNC:
  doc: |
    A placeholder for a function implemented in C.

  members:
    cfnc: the function pointer of the C function
    argc: the number of arguments the function takes, or -1 or -2

CDECL:
  doc: |
    Represents constant assignment of the form:
      vid = value

  members:
    value:
      doc: the value to be assigned to the constant
    vid:
      doc: the name of the constant to be assigned, all uppercase

CLASS:
  doc: |
    Represents a class definition, e.g.:
      class cpath
        body
      end

    or:
      class cpath < super
        body
      end

    The class definition is evaluated in a new lexical scope.

    The result of the expression is the last expression evaluated in the
    body.

  members:
    super:
      type: node or false
      doc: |
        an expression returning the base class, or false if there is no
        base class specified
    cpath:
      type: COLON2 or COLON3 node
      doc: the name of the class to define
    body:
      type: node
      doc: the body of the class definition

  version: '[180, oo)'

CLASS(2):
  doc: |
    Represents a class definition, e.g.:
      class cname
        body
      end

    or:
      class cname < super
        body
      end

    The class definition is evaluated in a new lexical scope.

    The result of the expression is the last expression evaluated in the
    body.

  members:
    super:
      type: node or false
      doc: |
        an expression returning the base class, or false if there is no
        base class specified
    cname:
      doc: the name of the class to define
    body:
      type: node
      doc: the body of the class definition

  version: '(0, 180)'

COLON2:
  doc: |
    Represents a constant lookup in a particular class.  This expression
    has the form:
      klass::mid

    where klass is the result of evaluating the expression in the head
    member.

  members:
    head:
      type: node
      doc: an expression specifying the class in which to do the lookup
    mid:
      type: id
      doc: the name of the method or constant to call/look up

COLON3:
  doc: |
    Represents a constant lookup or method call in class Object.  This
    expression has the form:
      ::mid

  members:
    mid:
      type: id
      doc: the name of the method or constant to call/look up

CONST:
  doc: |
    Represents a constant lookup in the current class.  The current
    class is the class in which the containing scope was defined.  The
    result of the expression is the value of the constant.

  members:
    vid:
      type: id
      doc: the name of the constant to look up

CREF:
  doc: |
    A temporary node used to store the value of ruby_cref or
    ruby_top_cref and later restore it.  The cref holds a reference to
    the cbase, which, among other things, is used for constant and class
    variable lookup.

    It should never be evaluated as an expression.
  members:
    clss:
      doc: the new class to use for the cbase.
    body:
      doc: always 0 (false)
    next:
      doc: the previous value of ruby_cref or ruby_top_cref
  version: (0, 190)

CVAR:
  doc: |
    Represents a class variable retrieval.  The result of the expression
    is the value of the class variable.
  members:
    vid:
      type: id
      doc: the name of the class variable, with two leading '@' characters.

CVASGN:
  doc: |
    Represents class variable assignment in a method context.

  members:
    value:
      type: node
      doc: |
        an expression whose result is the new value of the class
        variable
    vid:
      type: id
      doc: the name of the class variable to assign

CVDECL:
  doc: |
    Represents class variable assignment in a class context.

    A warning is emitted if the variable already exists.

  members:
    value:
      type: node
      doc: |
        an expression whose result is the new value of the class
        variable
    vid:
      type: id
      doc: the name of the class variable to assign

DASGN:
  doc: |
    Represents dynamic local variable assignment.  Dynamic assignment
    differs from static assignment in that the slots for static local
    variables are allocated when the method is called, wereas slots for
    dynamic variables are allocated when the variable is first assigned
    to.  When searching for the variable, dynamic assignment searches
    backward up the stack to see if the variable exists in any previous
    block in the current frame; if it does, it assigns to the slot found
    in that block, otherwise it creates a new variable slot.  As a
    result, dynamic assignment is typically much slower than static
    assignment.
  members:
    value:
      type: node
      doc: the value to assign to the local variable
    vid:
      type: id
      doc: the name of the local variable

DASGN_CURR:
  doc: |
    Represents dynamic local variable assignment in the current frame.
    See DASGN for a description of how dynamic assignment works.
  members:
    value:
      type: node
      doc: the value to assign to the local variable
    vid:
      type: id
      doc: the name of the local variable

DEFINED:
  doc: |
    Represents an expression using the 'defined?' keyword.  The result
    is either nil or a string describing the expression.
  members:
    head:
      type: node
      doc: the expression to inspect

DEFN:
  doc: |
    Represents a method definition, e.g.:
      def mid
        defn
      end
  members:
    defn:
      doc: the body of the method definition
    mid:
      doc: the name of the method* defn the body of the method
    noex:
      doc: the flags which should be used to define the method

DEFS:
  doc: |
    Represents a singleton method definition, e.g.:
      def recv.mid
        defn
      end
  members:
    defn:
    recv:
      type: node
      doc: the object to whose singleton class the new method is to be  added
    mid:
      type: id
      doc: the name of the method* defn the body of the method

DMETHOD:
  doc: |
    A placeholder for a method defined using define_method where the
    passed block is created from a Method object, e.g.:
      define_method(:name, method(:foo))

    See also BMETHOD.

  members:
    cval:
      doc: |
        the Method object passed to define_method, which contains the
        body of the method
  version: (0, 190)

DOT2:
  doc: |
    Represents a range created with the form:
      beg..end
    Creates a range which does not exclude the range end.
  members:
    beg:
      type: node
      doc: the beginning of the range
    end:
      type: node
      doc: the end of the range
    state:

DOT3:
  doc: |
    Represents a range created with the form:
      beg...end
    Creates a range which excludes the range end.
  members:
    beg:
      type: node
      doc: the beginning of the range
    end:
      type: node
      doc: the end of the range
    state:

DREGX:
  doc: |
    Represents a regular expresion with interpolation.  The node is
    evaluated by duplicating the regex stored in the 'lit' element, then
    iterating over the nodes stored in the 'next' element.  Each node
    found should evaluate to a string, and each resulting string is
    appended onto the original string.  Interpolation is represented
    with the EVSTR node.
  members:
    lit:
      type: object
      doc: a string
    next:
      type: ARRAY node
      doc: a list of expressions to be appended onto the string
    cflag:
      doc: |
        a bitfield containing the options used in the regular
        expression.  Valid values include:
        * RE_OPTION_IGNORECASE
        * RE_OPTION_EXTENDED
        * RE_OPTION_MULTILINE
        * RE_OPTION_SINGLELINE
        * RE_OPTION_LONGEST
        * RE_MAY_IGNORECASE
        * RE_OPTIMIZE_ANCHOR
        * RE_OPTIMIZE_EXACTN
        * RE_OPTIMIZE_NO_BM
        * RE_OPTIMIZE_BMATCH

DREGX_ONCE:
  doc: |
    Represents a regular expression with interpolation with the 'once'
    flag set.  The regular expression is only interpolated the first
    time it is encountered.
  members:
    lit:
      type: object
      doc: a string
    next:
      type: ARRAY node
      doc: a list of expressions to be appended onto the string
    cflag:
      doc: |
        a bitfield containing the options used in the regular
        expression.  See DREGX for a list of valid values.

DSTR:
  doc: |
    Represents a string object with interpolation.  The node is
    evaluated by duplicating the string stored in the 'lit' element,
    then iterating over the nodes stored in the 'next' element.  Each
    node found should evalate to a string, and each resulting string is
    appended onto the regex.  Interpolation is represented with the
    EVSTR node.
  members:
    lit:
      type: object
      doc: a string
    next:
      type: ARRAY node
      doc: a list of expressions to be appended onto the string

DSYM:
  doc: |
    Represents a symbol with interpolation, e.g.:
      :"#{next}"

    The node is evaluated by duplicating the string stored in the 'lit'
    element, then iterating over the nodes stored in the 'next' element.
    Each node found should evalate to a string, and each resulting
    string is appended onto the original string.  The final resulting
    string is then converted into a symbol.  Interpolation is
    represented with the EVSTR node.
  members:
    lit:
    next:
  version: '[180, oo)'

DVAR:
  doc: |
    Represents dynamic local variable retrieval.  See also DASGN.
  members:
    vid:
      type: id
      doc: the name of the local variable to retrieve.

DXSTR:
  doc: |
    Represents a string object with interpolation inside backticks,
    e.g.:
      `lit#{next}`

    The node is evaluated by duplicating the string stored in the 'lit'
    element, then iterating over the nodes stored in the 'next' element.
    Each node found should evalate to an string, and each resulting
    string is appended onto the original string.

    The resulting string is executed in a subshell and the output from
    its stdout stored in a string, which becomes the result of the
    expression.  Interpolation is represented with the EVSTR node.

  members:
    lit:
      type: object
      doc: a string
    next:
      type: ARRAY node
      doc: a list of expressions to be appended onto the string

ENSURE:
  doc: |
    Represents an ensure expression, e.g.:
      begin
        head
      ensure
        ensr
      end

    The head expression is first evaluated.  After the expression is
    evaluated, whether or not the expression raises an exception, the
    ensr expression is evaluated.

    See also RESCUE and RESBDOY.

  members:
    head:
      doc: the expression to protect
    ensr:
      doc: the expression to evaluate after the head is evaluated

EVSTR:
  doc: |
    Represents a single string interpolation.

    Evaluates the given expression and converts its result to a string
    with #to_s.

  members:
    lit:
      doc: a string containing an expression to evaluate
  version: '(0, 180)'

EVSTR(2):
  doc: |
    Represents a single string interpolation.

    Evaluates the given expression and converts its result to a string
    with #to_s.

  members:
    body:
      type: node
      doc: an expression to evaluate
  version: '[180, oo)'

'FALSE':
  doc: |
    Represents the keyword 'false'.
  members:

FBODY:
  doc: |
    A placeholder for a method alias, which can be added to a class by
    using alias or alias_method:
      alias old new

  members:
    orig:
      type: id
      doc: the original name of the method
    mid:
      type: id
      doc: the name of the method
    head:
      type: SCOPE node
      doc: the method body
  version: (0, 190)

FBODY(2):
  doc: |
    A placeholder for a method alias, which can be added to a class by
    using alias or alias_method:
      alias old new

  members:
    body:
      type: SCOPE node
      doc: the method body
    oid:
      type: id
      doc: the original name of the method
    cnt:
      doc: the method's flags
    #'
  version: '[190, oo)'

FCALL:
  doc: |
    Represents a method call in the form:
      mid(args).

    This makes a method call on an object using self as the implicit
    receiver.

  members:
    args:
      type: ARRAY node
      doc: the arguments to the method
    mid:
      type: id
      doc: the method id

FLIP2:
  doc: |
    Represents part of an awk-like flip-flop expression of the form:
      if beg..end then
        body
      end
  members:
    cnt:
      doc: |
        the index into the local variable table of the special variable
        to use in the flip-flop expression (usually 2 for $_)
    beg:
      doc: the beginning of the range
    end:
      doc: the end of the range

FLIP3:
  doc: |
    Represents part of a sed-like flip-flop expression of the form:
      if beg..end then
        body
      end
  members:
    cnt:
      doc: |
        the index into the local variable table of the special variable
        to use in the flip-flop expression (usually 2 for $_)
    beg:
      doc: the beginning of the range
    end:
      doc: the end of the range

FOR:
  doc: |
    Represents a loop constructed with the 'for' keyword, e.g.:
      for var in iter do
        body
      end

    This is equivalent to:
      iter.each do |*args|
      assign args to var
      body
    end

    Except that a new block is not created.

  members:
    body:
      type: node
      doc: the body of the loop
    iter:
      type: node
      doc: the sequence over which to iterate
    var:
      type: node
      doc: |
        an assignment node which assigns the next value in the sequence
        to a variable, which may or may not be local.  May also be a
        multiple assignment.

GASGN:
  doc: |
    Represents global variable assignment.

  members:
    value:
      type: node
      doc: an expression whose result is the new value of the global variable
    vid:
      type: id
      doc: the name of the global variable, with a leading '$' character.
    entry:

GVAR:
  doc: |
    Represents global variable retrieval.

  members:
    vid:
      type: id
      doc: the name of the global variable to retrieve, with a leading '$'
    entry:

HASH:
  doc: |
    Represents a hash table.  Evaluation of this node creates a new Hash
    by evaluating the given expressions and placing them into the table.

  members:
    head:
      type: ARRAY node
      doc: an array of successive keys and values

IASGN:
  doc: |
    Represents instance variable assignment.

  members:
    value:
      type: node
      doc: the value to assign to the instance variable
    vid:
      type: id
      doc: the name of the instance variable, with a leading '@' sign

IF:
  doc: |
    Represents a conditional of the form:
      if cond then
        body
      end

    or the form:
      if cond then
        body
      else
        else
      end

    The condition is first evaluated.  If it is true, then body is
    evaluated, otherwise else is evaluated.  The result is the value of
    the expression evaluated, or nil if there was no expression
    present.

    A conditional block using elsif has another IF node as the else
    expression.
        
  members:
    cond:
      type: node
      doc: the condition to evaluate
    body:
      type: false or node
      doc: |
        the expression to evaluate if the expression is true, or false
        if the expression is empty
    else:
      type: false or node
      doc: |
        the expression to evaluate if the expression is false, or false
        if the expression is empty

IFUNC:
  doc: |
    A temporary node used in iteration.

  members:
    cfnc:
      doc: a pointer to the C function to which to yield
    tval:
      doc: |
        the user-specified data to be passed as the second argument to
        cfnc
    state:
      doc: always 0

ITER:
  doc: |
    Represents an iteration loop, e.g.:
      iter do |*args|
        assign args to var
        body
      end

    A new block is created so that dynamic variables created inside the
    loop do not persist once the loop has terminated.

    If the iter node is a POSTEXE node, indicates that the expression
    should be evaluated when the program terminates.

  members:
    body:
      type: node
      doc: the body of the loop
    iter:
      type: node
      doc: |
        an expression which calls the desired iteration method, usually
        recv.each
    var:
      type: node
      doc: |
        an assignment node which assigns the next value in the sequence
        to a variable, which may or may not be local.  May also be a
        multiple assignment.

IVAR:
  doc: |
    A placeholder for an attribute reader method, which can added to a
    class by using attr_reader:
      attr_reader :attribute
    Its writer counterpart is ATTRSET.
  members:
    vid:
      doc: the name of the attribute, with a leading '@' sign

LASGN:
  doc: |
    Represents local variable assignment.
  members:
    value:
      type: node
      doc: the value to assign to the local variable
    vid:
      type: id
      doc: the name of the local variable
    cnt:

LIT:
  doc: |
    Represents a literal object.  The result of the expression is the
    object contained in this node.
  members:
    lit:
      type: object
      doc: the object

LVAR:
  doc: |
    Represents local variable retrieval.
  members:
    vid:
      type: id
      doc: the name of the local variable to retrieve.
    cnt:

MASGN:
  doc: |
    Represents multiple assignment.
  members:
    args:
      type: node
      doc: TODO
    head:
      type: node
      doc: TODO
    value:
      type: node
      doc: TODO

MATCH:
  doc: |
    Represents a regular expression match in a conditional, e.g.:
      if /lit/ then
        ...
      end

    This expression is equivalent to:
      if /lit/ =~ $_ then
        ...
      end

    On ruby 1.8 and newer, this type of expression causes ruby to emit a
    warning, unless script is running with -e.

  members:
    head:
      doc: the regular expression to use in the condition.
    value:
      doc: the value to compare against

  version: '(0, 180)'

MATCH(2):
  doc: |
    Represents a regular expression match in a conditional, e.g.:
      if /lit/ then
        ...
      end

    This expression is equivalent to:
      if /lit/ =~ $_ then
        ...
      end

    On ruby 1.8 and newer, this type of expression causes ruby to emit a
    warning, unless script is running with -e.

  members:
    lit:
      doc: the regular expression to use in the condition.
    value:
      doc: the value to compare against

  version: '[180, oo)'

MATCH2:
  doc: |
    Represents a match in a conditional with a regular expression using
    interpolation, e.g.:
      if /#{recv}/ then
        ...
      end

    which is equivalent to:
      if /#{recv}/ =~ $_ then
        ...
      end

    or a match with a regular expression on the left hand side and an
    expression on the right hand side, e.g.:

      /recv/ =~ value

  members:
    recv:
      doc: |
        the regular expression on the left hand side of the match
        operator
    value:
      doc: |
        the expression on the right hand side of the match operator, or
        an expression returning $_ if there is nothing on the right hand
        side

MATCH3:
  doc: |
    Represents a regular expression match of the form:
      recv =~ /value/

    where recv is an expression that returns an object and value is a
    regular expression literal.

  members:
    recv:
      type: node
      doc: the left hand side of the match
    value:
      type: LIT node
      doc: the right hand side of the match

MEMO:
  doc: |
    A node used for temporary storage.
    
    It is used by the rb_protect function so that the cont_protect
    variable can be restored when the function returns.

    It is also used in the Enumerable module and by autoload as a
    temporary placeholder.

    It should never be evaluated as an expression.

    It holds up to three nodes or ruby objects, depending on how it is
    used.

  members:

METHOD:
  doc: |
    A placeholder for a method entry in a class's method table.
  #'
  members:
    noex:
      doc: the method's flags
    #'
    body:
      doc: the body of the method
  version: '(0, 190)'

METHOD(2):
  doc: |
    A placeholder for a method entry in a class's method table.

    On ruby 1.9 this node type is also known as RUBY_VM_METHOD_NODE.
    Its use differs from that of NODE_METHOD in that it is used as the
    body of another METHOD node and is used to store the method's
    instruction sequence.
  #'
  members:
    body:
      doc: the body of the method
    clss:
      doc: |
        the class to which the method was added or the instruction
        sequence used to implement this method
    noex:
      doc: the method's flags
  #'
  version: '[190, oo)'

MODULE:
  doc: |
    Represents a module definition, e.g.:
      module cpath
        body
      end

    The module definition is evaluated in a new lexical scope.

    The result of the expression is the last expression evaluated in the
    body.

  members:
    cpath:
      type: COLON2 or COLON3 node
      doc: the name of the module to define
    body:
      type: node
      doc: the body of the module definition

  version: '[180, oo)'

MODULE(2):
  doc: |
    Represents a module definition, e.g.:
      module cname
        body
      end

    The module definition is evaluated in a new lexical scope.

    The result of the expression is the last expression evaluated in the
    body.

  members:
    cname:
      doc: the name of the module to define
    body:
      type: node
      doc: the body of the module definition

  version: '(0, 180)'

NEWLINE:
  doc: |
    Represents the termination of a line.  This is used for calling
    event hooks when a new line of code is reached.
  members:
    next:
      type: node
      doc: the expression on the next line
  version: (0, 190)

NEXT:
  doc: |
    Represents the 'next' keyword.
    Causes control to be transferred to the end of the loop, causing the
    next value in the sequence to be retrieved.
  members:
    stts:

NIL:
  doc: |
    Represents the keyword 'nil'.
  members:

NOT:
  doc: |
    Represents a logical negation.
  members:
    body:
      type: node
      doc: the value to negate.
  version: (0, 190)

NTH_REF:
  doc: |
    Represents the nth match data item, e.g. $1, $2, etc.
  members:
    nth:
      doc: |
        the index of the match data item to retrieve
    cnt:
      doc: |
        the index into the local variable table where the match data is stored

OP_ASGN1:
  doc: |
    Represents bracket assignment of the form:
      recv[index] += value or 
      recv[index] ||= value or
      recv[index] &&= value.

    The index is obtained from args.body.

    The value is obtained from args.head.

    In the case of ||=, mid will be 0.  The rhs will be equal to the
    result of evaluating args.head if the lhs is false, otherwise the
    rhs will be equal to lhs.

    In the case of &&=, mid will be 1.  The rhs will be equal to the lhs
    if lhs is false, otherwise the rhs will be equal to the result of
    evaluating args.head.  In all other cases, mid will be the name of
    the method to call to calculate value, such that the expression is
    equivalent to:
      recv[args.body] = recv[args.body].mid(args.head)

    In no case does ruby short-circuit the assignment.

  members:
    args:
      type: ARGSCAT node
      doc: the arguments to the assigment
    mid:
      type: id
      doc: |
        0, 1, or the name a method to call to calculate the value of the
        rhs
    recv:
      type: node
      doc: the receiver of the assignment

OP_ASGN2:
  doc: |
    Represents attribute assignment of the form:
      recv.attr op value

    where recv is the receiver of the attr method, attr is the attribute
    to which to assign, op is an assignment operation (e.g. +=), and
    value is the value to assign to the attribute.

    The 'next' member of this class is also of type OP_ASGN2, though it
    has different members than its parent.  This child node is
    documented under OP_ASGN2_ARG.

  members:
    recv:
      doc: the receiver of the attribute
    next:
      doc: |
        another node of type OP_ASGN2 which contains more information
        about the assignment operation than can fit in this node alone
    value:
      doc: the value to assign to the attribute

OP_ASGN2_ARG:
  doc: |
    Actually a node of type OP_ASGN2, this is a placeholder for
    additional information about the assignment than can fit in a single
    OP_ASGN2 node.

  members:
    vid:
      doc: |
        The method to call on the receiver to retrieve the attribute

    aid:
      doc: |
        The method to call on the receiver to set the attribute

    mid:
      doc: |
        The operation to apply to the attribute before setting it.  May
        be 0 (false) to indicate "logical or" or 1 (nil) to indicate
        "logical and".

OP_ASGN_AND:
  doc: |  
    Represents an expression of the form:
      recv &&= value
    Ruby will evaluate the expression on the left hand side of the
    assignment; if it is true, then it will assign the result of the
    expression on the right hand side to the receiver on the left hand
    side.
  members:
    recv:
      type: node
      doc: |
        an expression representing the left hand side of the assignment
    value:
      type: node
      doc: |
        an expression representing the assignment that should be
        performed if the left hand side is true

OP_ASGN_OR:
  doc: |
    Represents an expression of the form:
      recv ||= value
    Ruby will evaluate the expression on the left hand side.  If it is
    undefined, nil, or false, then ruby will evaluate the expression on
    the right hand side and assign it to recv.  The expression will
    short-circuit if recv is defined and true (non-false, non-nil).
  members:
    aid:
      type: id
      doc: |
        if this indicator is nonzero, ruby will check to see if the
        provided expression is defined, otherwise it will assume that
        the provided expression is defined.
    value:
      type: node
      doc: the right hand side of the assignment
    recv:
      type: node
      doc: the receiver of the assignment

OPT_N:
  doc: |
    Represents the top-level loop when the -n or -p options are used
    with the interpreter.

  members:
    body:
      doc: the body of the loop

OR:
  doc: |
    Represents a logical 'or' of the form:
      first || second
    The expression will short-circuit and yield the result of the left
    hand side if it is true, else it will evaluate the right hand side
    and use it as the result of the expression.
  members:
    2nd:
      type: node
      doc: the expression on the right hand side
    1st:
      type: node
      doc: the expression on the left hand side

POSTEXE:
  doc: |
    Represents the END keyword, e.g.:
      END { ... }

    Indicating that the enclosing ITER node is to be excecuted only
    once, when the program terminates.

  members:

REDO:
  doc: |
    Represents the 'redo' keyword.  Causes control to be transferred to
    the beginning of the loop.  The loop assignment is not repeated.
  members:

RESBODY:
  doc: |
    Represents the rescue portion of a rescue expression (see RESCUE for
    examples).

    If the head node of the rescue expresion raises an exception, the
    resq node is evaluated.  The resq node is of type RESBDOY.
    
    As it is evaluated, the type of the exception is tested against the
    class(es) listed in the args node.  If there is a match, the body
    node is evaluated, otherwise the head node is evaluated.  The head
    node is either another RESBDOY node or false (0).

  members:
    head:
      doc: the next rescue
    body:
      doc: the expresion to evaluate if the exception type matches
    args:
      doc: the expression type to match against

RESCUE:
  doc: |
    Represents part of a rescue expression of the form:
      head rescue expr

    or the longer form:
      begin
        head
      rescue exception
        expr
      end

    or the form using the else keyword:
      begin
        head
      rescue exception
        expr
      else
        else_expr
      end

    The head expression is first evaluated, and if an exception is
    raised, evaluates the resq node.  If no exception is raised, the
    else node is evaluated if it is not false (0).

    The resq node will be a RESBDOY node, which will test the exception
    to see if it matches one of the expected types.  If it does it will
    handle the exception, otherwise it will allow the expression to pass
    to the outer scope.

  members:
    head:
      doc: the body of the block to evaluate
    resq:
      doc: the expression to be evaluated if an exception is raised
    else:
      doc: the expression to be evaluated if no exception is raised

RESTARY:
  doc: |
    No longer used.
  members:
    head:
  version: '[170, 180]'

RESTARY2:
  doc: |
    No longer used.
  members:
    head:
  version: '(170, 180]'

RETRY:
  doc: |
    Represents the retry keyword.

  members:

RETURN:
  doc: |
    Represents the 'return' keyword.  Evaluation of this node results in
    a return from the current method.  If no argument is supplied,
    returns nil, otherwise returns the result of the supplied
    expression.
  members:
    stts:
      type: node or 0
      doc: an expression representing the value to return

REXPAND:
  doc: |
    No longer used.
  members:
    head:
  version: '[170, 180)'

SCLASS:
  doc: |
    Represents the body of a singleton class definition, e.g.:
      class << recv
        body
      end

    The class definition is evaluated in a new lexical scope.

    The result of the expression is the last expression evaluated in the
    body.

  members:
    body:
      type: node
      doc: the body of the class definition
    recv:
      type: node
      doc: the object whose singleton class is to be modified

SCOPE:
  doc: |
    Represents a lexical scope.

    A new scope is created when a method is invoked.  The scope node
    holds information about local variables and arguments to the method.
    The first two variables in the local variable table are the implicit
    variables $_ and $~.

    The next variables listed in the local variable table are the
    arguments to the method.  More information about the arguments to
    the method are stored in the ARGS node, which will either be the
    first node in the scope or the first node in the BLOCK held by the
    scope.

  members:
    tbl:
      type: pointer to array of ID
      doc: |
        the names of the local variables* next the first expression in
        the scope
    rval:
      type: node
      doc: |
        holds information about which class(es) to search for  constants
        in this scope
    next:
      type: node
      doc: the body of the lexical scope

SELF:
  doc: |
    Represents the keyword 'self'.
  members:

SPLAT:
  doc: |
    Represents the splat (*) operation as an rvalue, e.g.:
      *head
    If the argument is an array, returns self.
    If the argument is nil, returns [nil].
    If the argument is any other value, returns the result of calling #to_a on the
    argument.
  members:
    head:
      type: node
      doc: the argument to splat.
  version: '[180, oo)'

STR:
  doc: |
    Represents a string object.  Duplicates the string stored in the
    node.
  members:
    lit:
      type: object
      doc: the string to be duplicated

SUPER:
  doc: |
    Represents the keyword 'super' when used with parens or with arguments.
  members:
    args:
      type: ARRAY node
      doc: the arguments to be passed to the base class
     
SVALUE:
  doc: |
    Represents the collection of multiple values of the right hand side
    of an assignment into a single value, for use in single assignment,
    e.g.:
      lhs = a, b, c
    The argument to this node is an Array.
    If it is length 0, returns nil.
    If it is length 1, returns the first element in the array.
    Otherwise, returns the array.
  members:
    head:
      type: node
      doc: an expression which returns an Array.
  version: '[180, 190)'

'TRUE':
  doc: |
    Represents the keyword 'true'.
  members:

UNDEF:
  doc: |
    Represents an expression using the undef keyword, e.g.:
      undef :mid

    This causes the method identified by mid in the current class to be
    undefined.

  members:
    mid:
      doc: the id of the method to undefine
  version: '(0, 185)'

UNDEF(2):
  doc: |
    Represents an expression using the undef keyword, e.g.:
      undef :mid

    This causes the method identified by mid in the current class to be
    undefined.

  members:
    body:
      doc: an expression returning the id of the method to undefine
  version: '[185, oo)'

UNTIL:
  doc: |
    Represents a loop constructed with the 'until' keyword, e.g.:
      until cond do
        body
      end
  members:
    body:
      type: node
      doc: the body of the loop
    cond:
      type: node
      doc: a condition to terminate the loop when it becomes true
    state:

VCALL:
  doc: |
    Represents a local variable or a method call without an explicit
    receiver, to be determined at run-time.
  members:
    mid:
      type: id
      doc: the name of the variable or method

WHILE:
  doc: |
    Represents a loop constructed with the 'while' keyword, e.g.:
      while cond do
        body
      end
  members:
    body:
      type: node
      doc: the body of the loop
    cond:
      type: node
      doc: a condition to terminate the loop when it becomes false
    state:

XSTR:
  doc: |
    Represents a string object inside backticks, e.g.:
      `lit`
    The given string is executed in a subshell and the output from its
    stdout stored in a string.
  members:
    lit:
      type: object
      doc: the string to be executed

YIELD:
  doc: |
    Represents the 'yield' keyword.  When evaluated, causes control of
    the program to be transferred to the block passed by the calling
    scope.
  members:
    head:
      type: node
      doc: the value to yield
    state:
      type: int
      doc: if nonzero, splats the value before yielding

ZSUPER:
  doc: |
    Represents the keyword 'super' when used without parens nor
    arguments.  The arguments to the base class method are obtained from
    the arguments passed to the current method, which are store in the
    current frame.

    Can also be a placeholder for a method when its implementation is
    deferred to the base class.

  members:

TO_ARY:
  doc: |
    Represents a conversion from one object type to an array type.
    Evaluation of this node converts its argument to an array by calling
    \#to_ary on the argument.
  members:
    head:
      type: node
      doc: the object to convert to an array
  version: '[180, oo)'

WHEN:
  doc: |
    Represents either a conditional in a case/end block:
      case value
      when head
        body
      next
      end

    or the first element of a a case/end block with no conditional:
      case
      when head
        body
      next
      end

    In the first case, value is evaluated and head is evaluated, and
    they are compared using head === value.  If the result is true, then
    body is evaluated and no more when conditions are tried, otherwise
    the interpreter evaluates the next node.

    In the second case, head is tested using rtest(value).  If the
    result is true, then body is evaluated and no more when conditions
    are tried, otherwise the interpreter evaluates the next node.

    If the condition evaluates to false and there are no more when
    conditions to try, the result of the expression is nil.

    If the next expression to try is not a WHEN node, then it represents
    an else element and is evaluated unconditionally.

  members:
    head:
      doc: a value to compare against, or a condition to be tested
    body:
      doc: an expression to evaluate if the condition evaluates to true
    next:
      type: false or WHEN node
      doc: the next expression to be evaluated if the condition is false

VALIAS:
  doc: |
    Represents an alias expression of the form:
      alias 1st 2nd
    where 2nd is the name of a variable and 1st is the name of its new
    alias.
  members:
    1st: the name of an exiting variable
    2nd: the name of its new alias

ZARRAY:
  doc: |
    Represents an array of zero elements.  Evalation of this node
    creates a new array of length zero.
  members:

