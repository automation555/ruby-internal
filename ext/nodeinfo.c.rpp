#include "nodeinfo.h"
#include "version.h"
#include "global_entry.h"

static VALUE variable_names(ID * tbl)
{
  if(tbl)
  {
    size_t j;
    VALUE arr = rb_ary_new();
    /* A tbl contains the names of local variables.  The first
     * element is the size of the table.  The next two elements
     * are $_ and $~.  The rest of the elements are the names of
     * the variables themselves.
     */
    for(j = 3; j <= tbl[0]; ++j)
    {
      rb_id2name(tbl[j]);
      if(tbl[j] == 0)
      {
        /* flip state */
        rb_ary_push(arr, Qnil);
      }
      else
      {
        rb_ary_push(arr, ID2SYM(tbl[j]));
      }
    }
    return arr;
  }
  else
  {
    return Qnil;
  }
}

/* Every node contains three elements.  This function takes any one of
 * those elements, converts it to a Ruby object that can be dumped
 * (since nodes can't be dumped), and puts the resulting object into
 * node_hash.
 */
VALUE dump_node_elem(enum Node_Elem_Name nen, NODE * n, VALUE node_hash)
{
  switch(nen)
  {
    case NEN_NONE:
      return Qnil;
#ruby <<END
  require 'read_node_h.rb'

  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
    case NEN_#{node_elem_name.upcase}:
    END

    if node_elem_name == "noex" then
      # noex points to an id but is really a long
      node_elem_ref.sub('id', 'cnt')
    end

    case node_elem_ref
    when /\.node$/, /\.value/
      puts <<-END
      if(TYPE(n->nd_#{node_elem_name}) == T_NODE)
      {
        /* node */
        if(n->nd_#{node_elem_name})
        {
          dump_node_to_hash((NODE *)n->nd_#{node_elem_name}, node_hash);
          return rb_assoc_new(Qtrue, node_id((NODE *)n->nd_#{node_elem_name}));
        }
        else
        {
          return rb_assoc_new(Qtrue, Qnil);
        }
      }
      if(   TYPE(n->nd_#{node_elem_name}) == T_CLASS
         || TYPE(n->nd_#{node_elem_name}) == T_MODULE)
      {
        /* TODO */
        return rb_assoc_new(Qfalse, Qnil);
      }
      else
      {
        /* object */
        return rb_assoc_new(Qfalse, (VALUE)n->nd_#{node_elem_name});
      }
      END
    when /\.id$/
      puts <<-END
      if(n->nd_#{node_elem_name} == 0)
      {
        rb_raise(
            rb_eRuntimeError,
            "Invalid ID for #{node_elem_name} (node type=%d)",
            nd_type(n));
      }
      return ID2SYM(n->nd_#{node_elem_name});
      END
    when /\.(argc|state|cnt)$/
      puts <<-END
      {
      VALUE retval = LONG2NUM(n->#{node_elem_ref});
      return retval;
      }
      END
    when /\.(tbl)$/
      puts <<-END
      return variable_names(n->nd_#{node_elem_name});
      END
    when /\.(entry)$/
      puts <<-END
      if(n->nd_#{node_elem_name}->id == 0)
      {
        rb_raise(
            rb_eRuntimeError,
            "Invalid ID for #{node_elem_name} (node type %d)",
            nd_type(n));
      }
      return ID2SYM(n->nd_#{node_elem_name}->id);
      END
    when /\.(cfunc)$/
      puts <<-END
      rb_raise(rb_eArgError, "Cannot dump #{$1}");
      END
    end
  end
  nil
END
  }
  rb_raise(rb_eArgError, "Invalid Node_Elem_Name %d", nen);
}

void load_node_elem(enum Node_Elem_Name nen, VALUE v, NODE * n, VALUE node_hash, VALUE id_hash)
{
  switch(nen)
  {
    case NEN_NONE:
      return;
#ruby <<END
  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
    case NEN_#{node_elem_name.upcase}:
    END

    if node_elem_name == "noex" then
      # noex points to an id but is really a long
      node_elem_ref.sub('id', 'cnt')
    end

    case node_elem_ref
    when /\.node$/, /\.value$/
      puts <<-END
      Check_Type(v, T_ARRAY);
      if(RTEST(RARRAY(v)->ptr[0]))
      {
        /* node */
        v = RARRAY(v)->ptr[1];
        if(v == Qnil)
        {
          n->nd_#{node_elem_name} = 0;
        }
        else
        {
          VALUE nid = rb_hash_aref(id_hash, v);
          if(RTEST(nid))
          {
            *(NODE **)(&n->nd_#{node_elem_name}) = id_to_node(nid);
          }
          else
          {
            NODE * new_node = NEW_NIL();
            load_node_from_hash(new_node, v, node_hash, id_hash);
            *(NODE **)(&n->#{node_elem_ref}) = new_node;
          }
        }
      }
      else
      {
        /* object */
        *(VALUE *)(&n->nd_#{node_elem_name}) = RARRAY(v)->ptr[1];
      }
      return;
      END
    when /\.id$/
      puts <<-END
      n->nd_#{node_elem_name} = SYM2ID(v);
      return;
      END
    when /\.(argc|state|cnt)$/
      puts <<-END
      n->nd_#{node_elem_name} = NUM2LONG(v);
      return;
      END
    when /\.(tbl)$/
      puts <<-END
      if(v == Qnil)
      {
        n->nd_#{node_elem_name} = 0;
      }
      else
      {
        Check_Type(v, T_ARRAY);
        size_t len = RARRAY(v)->len;
        ID * tmp_tbl = ALLOCA_N(ID, len + 3);
        size_t j;
        tmp_tbl[0] = (ID)(len + 2);
        tmp_tbl[1] = (ID)('_');
        tmp_tbl[2] = (ID)('~');
        for(j = 0; j < len; ++j)
        {
          VALUE e = RARRAY(v)->ptr[j];
          if(e == Qnil)
          {
            /* flip state */
            tmp_tbl[j + 3] = 0;
          }
          else
          {
            tmp_tbl[j + 3] = SYM2ID(e);
          }
        }
        n->nd_#{node_elem_name} = ALLOC_N(ID, len + 3);
        memcpy(n->nd_#{node_elem_name}, tmp_tbl, len + 3);
      }
      return;
      END
    when /\.(entry)$/
      puts <<-END
      n->nd_#{node_elem_name} = rb_global_entry(SYM2ID(v));
      return;
      END
    when /\.(cfunc)$/
      puts <<-END
      rb_raise(rb_eRuntimeError, "Cannot load #{$1}");
      END
    end
  end
  nil
END
  }
  rb_raise(rb_eRuntimeError, "Internal error: invalid Node_Elem_Name %d", nen);
}

#ruby <<END
  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    if node_elem_name == "noex" then
      # noex points to an id but is really a long
      node_elem_ref.sub('id', 'cnt')
    end

    case node_elem_ref
    when /\.node$/, /\.value$/
      puts <<-END
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);

  if(TYPE(n->nd_#{node_elem_name}) == T_NODE)
  {
    return wrap_node((NODE *)n->nd_#{node_elem_name});
  }
  else
  {
    return (VALUE)n->nd_#{node_elem_name};
  }
}
      END
    when /\.id$/
      puts <<-END
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  if(n->nd_#{node_elem_name} == 0)
  {
    rb_raise(
        rb_eRuntimeError,
        "Invalid ID for #{node_elem_name} (node type=%d)",
        nd_type(n));
  }
  return ID2SYM(n->nd_#{node_elem_name});
}
      END
    when /\.(argc|state|cnt)$/
      puts <<-END
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  return LONG2NUM(n->nd_#{node_elem_name});
}
      END
    when /\.(tbl)$/
      puts <<-END
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  return variable_names(n->nd_#{node_elem_name});
}
      END
    when /\.(entry)$/
      puts <<-END
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  if(n->nd_#{node_elem_name}->id == 0)
  {
    rb_raise(
        rb_eRuntimeError,
        "Invalid ID for #{node_elem_name} (node type %d)",
        nd_type(n));
  }
  return ID2SYM(n->nd_#{node_elem_name}->id);
}
      END
    when /\.(cfunc)$/
      puts <<-END
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  return LONG2NUM((long)(n->nd_#{node_elem_name}));
}
      END
    end
  end
  nil
END

void define_node_elem_methods(enum Node_Elem_Name nen, VALUE klass)
{
  VALUE members = rb_iv_get(klass, "__member__");

  switch(nen)
  {
    case NEN_NONE:
      return;
#ruby <<END
  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
      case NEN_#{node_elem_name.upcase}:
      rb_define_method(klass, "#{node_elem_name}", node_#{node_elem_name}, 0);
      rb_ary_push(members, rb_str_new2("#{node_elem_name}"));
      return;
    END
  end
  nil
END
  }
  rb_raise(rb_eRuntimeError, "Internal error: invalid Node_Elem_Name %d", nen);
}

