#include "nodeinfo.h"
#include "version.h"
#include "global_entry.h"

/* Every node contains three elements.  This function takes any one of
 * those elements, converts it to a Ruby object that can be dumped
 * (since nodes can't be dumped), and puts the resulting object into
 * node_hash.
 */
VALUE dump_node_elem(enum Node_Elem_Name nen, NODE * n, VALUE node_hash)
{
  switch(nen)
  {
    case NEN_NONE:
      return Qnil;
#ruby <<END
  require 'read_node_h.rb'

  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
    case NEN_#{node_elem_name.upcase}:
    END
    case node_elem_name
    when "rval"
      # TODO: I'm sure I had a reason for writing this, but I don't know
      # what it was.  My code segfaults if I keep this.
      # puts "return dump_node_elem(NEN_HEAD, n, node_hash);"
      puts <<-END
      return Qnil;
      END
    when "noex"
      puts <<-END
      return INT2NUM(n->nd_noex);
      END
    else
      case node_elem_ref
      when /\.node$/
        puts <<-END
        if(n->nd_#{node_elem_name})
        {
          dump_node_to_hash(n->nd_#{node_elem_name}, node_hash);
          return node_id(n->nd_#{node_elem_name});
        }
        else
        {
          return Qnil;
        }
        END
      when /\.id$/
        puts <<-END
        if(n->nd_#{node_elem_name} == 0)
        {
          rb_raise(rb_eRuntimeError, "Invalid ID");
        }
        return ID2SYM(n->nd_#{node_elem_name});
        END
      when /\.value$/
        puts <<-END
        return n->nd_#{node_elem_name};
        END
      when /\.(argc|state|cnt)$/
        puts <<-END
        return INT2NUM(n->nd_#{node_elem_name});
        END
      when /\.(tbl)$/
        puts <<-END
        if(n->nd_#{node_elem_name})
        {
          size_t j;
          VALUE arr = rb_ary_new();
          /* A tbl contains the name of local variables.  The first
           * element is the size of the table.  The next two elements
           * are $_ and $~.  The rest of the elements are the names of
           * the variables themselves.
           */
          for(j = 3; j <= n->nd_#{node_elem_name}[0]; ++j)
          {
            rb_id2name(n->nd_#{node_elem_name}[j]);
            if(n->nd_#{node_elem_name}[j] == 0)
            {
              rb_raise(rb_eRuntimeError, "Invalid ID");
            }
            rb_ary_push(arr, ID2SYM(n->nd_#{node_elem_name}[j]));
          }
          return arr;
        }
        else
        {
          return Qnil;
        }
        END
      when /\.(entry)$/
        puts <<-END
        if(n->nd_#{node_elem_name}->id == 0)
        {
          rb_raise(rb_eRuntimeError, "Invalid ID");
        }
        return ID2SYM(n->nd_#{node_elem_name}->id);
        END
      when /\.(cfunc)$/,
           /\.(argc|state|cnt)$/
        puts <<-END
        rb_raise(rb_eArgError, "Cannot dump #{$1}");
        END
      end
    end
  end
  nil
END
  }
  rb_raise(rb_eArgError, "Invalid Node_Elem_Name %d", nen);
}

void load_node_elem(enum Node_Elem_Name nen, VALUE v, NODE * n, VALUE node_hash, VALUE id_hash)
{
  switch(nen)
  {
    case NEN_NONE:
      return;
#ruby <<END
  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
    case NEN_#{node_elem_name.upcase}:
    END
    case node_elem_name
    when "rval"
      puts <<-END
      load_node_elem(NEN_HEAD, v, n, node_hash, id_hash);
      return;
      END
    when "noex"
      puts <<-END
      n->nd_noex = NUM2INT(v);
      return;
      END
    else
      case node_elem_ref
      when /\.node$/
        puts <<-END
        {
          VALUE nid = rb_hash_aref(id_hash, v);
          if(RTEST(nid))
          {
            n->nd_#{node_elem_name} = id_to_node(nid);
          }
          else if(v == Qnil)
          {
            n->nd_#{node_elem_name} = 0;
          }
          else
          {
            NODE * new_node = NEW_NIL();
            load_node_from_hash(new_node, v, node_hash, id_hash);
            n->nd_#{node_elem_name} = new_node;
          }
          return;
        }
        END
      when /\.id$/
        puts <<-END
        n->nd_#{node_elem_name} = SYM2ID(v);
        return;
        END
      when /\.value$/
        puts <<-END
        n->nd_#{node_elem_name} = v;
        return;
        END
      when /\.(argc|state|cnt)$/
        puts <<-END
        n->nd_#{node_elem_name} = NUM2INT(v);
        return;
        END
      when /\.(tbl)$/
        puts <<-END
        if(v == Qnil)
        {
          n->nd_#{node_elem_name} = 0;
        }
        else
        {
          Check_Type(v, T_ARRAY);
          size_t len = RARRAY(v)->len;
          ID * tmp_tbl = ALLOCA_N(ID, len);
          size_t j;
          tmp_tbl[0] = (ID)(len + 2);
          tmp_tbl[1] = (ID)('_');
          tmp_tbl[2] = (ID)('~');
          for(j = 0; j < len; ++j)
          {
            tmp_tbl[j + 3] = SYM2ID(RARRAY(v)->ptr[j]);
          }
          n->nd_#{node_elem_name} = ALLOC_N(ID, len + 3);
          memcpy(n->nd_#{node_elem_name}, tmp_tbl, len + 3);
        }
        return;
        END
      when /\.(entry)$/
        puts <<-END
        n->nd_#{node_elem_name} = rb_global_entry(SYM2ID(v));
        return;
        END
      when /\.(cfunc)$/,
           /\.(argc|state|cnt)$/
        puts <<-END
        rb_raise(rb_eRuntimeError, "Cannot load #{$1}");
        END
      end
    end
  end
  nil
END
  }
  rb_raise(rb_eRuntimeError, "Internal error: invalid Node_Elem_Name %d", nen);
}

