#include "nodeinfo.h"
#include "version.h"
#include "global_entry.h"
#include "builtins.h"

static int is_flip_state(ID id)
{
  if(id == 0)
  {
    return 1;
  }
#if RUBY_VERSION_CODE >= 180
  if(!rb_is_local_id(id))
  {
    return 1;
  }
#endif
  return 0;
}

static VALUE variable_names(ID * tbl)
{
  if(tbl)
  {
    size_t j;
    VALUE arr = rb_ary_new();
    /* A tbl contains the names of local variables.  The first
     * element is the size of the table.  The next two elements
     * are $_ and $~.  The rest of the elements are the names of
     * the variables themselves.
     */
    for(j = 3; j <= tbl[0]; ++j)
    {
      if(is_flip_state(tbl[j]))
      {
        /* flip state */
        rb_ary_push(arr, Qnil);
      }
      else
      {
        rb_ary_push(arr, ID2SYM(tbl[j]));
      }
    }
    return arr;
  }
  else
  {
    return Qnil;
  }
}

/* Every node contains three elements.  This function takes any one of
 * those elements, converts it to a Ruby object that can be dumped
 * (since nodes can't be dumped), and puts the resulting object into
 * node_hash.
 */
VALUE dump_node_elem(enum Node_Elem_Name nen, NODE * n, VALUE node_hash)
{
  switch(nen)
  {
    case NEN_NONE:
      return Qnil;
#ruby <<END
  require 'read_node_h.rb'
  require 'node_type_descrip.rb'

  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
    case NEN_#{node_elem_name.upcase}:
    END

    if node_elem_name == "noex" or node_elem_name == "cflag" then
      # noex and cflag point to an id but are really a long
      node_elem_ref.sub!('id', 'cnt')
    end

    if node_elem_name == "rval" then
      # rval points to a value but is really a node
      node_elem_ref.sub!('value', 'node')
      node_elem_name = '2nd'
    end

    case node_elem_ref
    when /\.node/
      puts <<-END
      if(n->nd_#{node_elem_name})
      {
        dump_node_or_iseq_to_hash((VALUE)n->nd_#{node_elem_name}, node_hash);
        return node_id(n->nd_#{node_elem_name});
      }
      else
      {
        return Qnil;
      }
      END
    when /\.value$/
      puts <<-END
      switch(TYPE(n->nd_#{node_elem_name}))
      {
        case T_CLASS:
        case T_MODULE:
        {
          /* When dumping a class, we dump just the name (otherwise we'd
           * get multiple copies of the class each time we load a method
           * on the other side).
           */
          VALUE klass = (VALUE)n->nd_#{node_elem_name};
          VALUE path;
          if(FL_TEST(klass, FL_SINGLETON))
          {
            VALUE singleton = rb_iv_get(klass, "__attached__");
            path = rb_class_path(singleton);
          }
          else
          {
            path = rb_class_path(klass);
            if(STR2CSTR(path)[0] == '#')
            {
              rb_raise(rb_eArgError, "cannot dump anonymous class");
            }
          }
          return rb_assoc_new(
              INT2NUM(((struct RBasic *)(n->nd_#{node_elem_name}))->flags),
              path);
        }
        
        default:
          /* TODO: would like to dump flags, not type */
          return rb_assoc_new(
              INT2NUM(TYPE((VALUE)n->nd_#{node_elem_name})),
              (VALUE)n->nd_#{node_elem_name});
      }
      END
    when /\.id$/
      puts <<-END
      if(n->nd_#{node_elem_name} == 0)
      {
        rb_raise(
            rb_eRuntimeError,
            "Invalid ID for #{node_elem_name} (node type=%d)",
            nd_type(n));
      }
      return ID2SYM(n->nd_#{node_elem_name});
      END
    when /\.(argc|state|cnt)$/
      puts <<-END
      {
      return LONG2NUM((long)n->nd_#{node_elem_name});
      }
      END
    when /\.(tbl)$/
      puts <<-END
      {
      VALUE v = variable_names(n->nd_#{node_elem_name});
      return v;
      }
      END
    when /\.(entry)$/
      puts <<-END
      if(n->nd_#{node_elem_name}->id == 0)
      {
        rb_raise(
            rb_eRuntimeError,
            "Invalid ID for #{node_elem_name} (node type %d)",
            nd_type(n));
      }
      return ID2SYM(n->nd_#{node_elem_name}->id);
      END
    when /\.(cfunc)$/
      puts <<-END
      rb_raise(rb_eArgError, "Cannot dump #{$1}");
      END
    end
  end
  nil
END
  }
  rb_raise(rb_eArgError, "Invalid Node_Elem_Name %d", nen);
}

void load_node_elem(enum Node_Elem_Name nen, VALUE v, NODE * n, VALUE node_hash, VALUE id_hash)
{
  switch(nen)
  {
    case NEN_NONE:
      return;
#ruby <<END
  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    puts <<-END
    case NEN_#{node_elem_name.upcase}:
    {
    END

    if node_elem_name == "noex" or node_elem_name == "cflag" then
      # noex and cflag point to an id but are really a long
      node_elem_ref.sub!('id', 'cnt')
    end

    if node_elem_name == "rval" then
      # rval points to a value but is really a node
      node_elem_ref.sub!('value', 'node')
      node_elem_name = '2nd'
    end

    case node_elem_ref
    when /\.node$/
      puts <<-END
      if(v == Qnil)
      {
        n->nd_#{node_elem_name} = 0;
      }
      else
      {
        VALUE nid = rb_hash_aref(id_hash, v);
        if(RTEST(nid))
        {
          n->nd_#{node_elem_name} = id_to_node(nid);
        }
        else
        {
          n->#{node_elem_ref} = (NODE *)load_node_or_iseq_from_hash(
              v, node_hash, id_hash);
        }
      }
      return;
      END
    when /\.value$/
      puts <<-END
      Check_Type(v, T_ARRAY);
      if(RARRAY_LEN(v) != 2)
      {
        rb_raise(rb_eArgError, "wrong size for array");
      }
      int flags = NUM2INT(RARRAY_PTR(v)[0]);
      switch(flags & T_MASK)
      {
        case T_CLASS:
        case T_MODULE:
        {
          VALUE str = RARRAY_PTR(v)[1];
          Check_Type(str, T_STRING);
          VALUE klass = rb_path2class(STR2CSTR(str));
          if(flags & FL_SINGLETON)
          {
            *(VALUE *)(&n->nd_#{node_elem_name}) =
              rb_singleton_class(klass);
          }
          else
          {
            *(VALUE *)(&n->nd_#{node_elem_name}) =
              klass;
          }
          break;
        }
        default:
          *(VALUE *)(&n->nd_#{node_elem_name}) = RARRAY_PTR(v)[1];
          break;
      }
      return;
      END
    when /\.id$/
      puts <<-END
      n->nd_#{node_elem_name} = SYM2ID(v);
      return;
      END
    when /\.(argc|state|cnt)$/
      puts <<-END
      n->nd_#{node_elem_name} = NUM2LONG(v);
      return;
      END
    when /\.(tbl)$/
      puts <<-END
      if(v == Qnil)
      {
        n->nd_#{node_elem_name} = 0;
      }
      else
      {
        size_t len, j;
        ID * tmp_tbl;

        Check_Type(v, T_ARRAY);
        len = RARRAY_LEN(v);
        tmp_tbl = ALLOCA_N(ID, len + 3);
        tmp_tbl[0] = (ID)(len + 2);
        tmp_tbl[1] = (ID)('_');
        tmp_tbl[2] = (ID)('~');
        for(j = 0; j < len; ++j)
        {
          VALUE e = RARRAY_PTR(v)[j];
          if(e == Qnil)
          {
            /* flip state */
            tmp_tbl[j + 3] = 0;
          }
          else
          {
            tmp_tbl[j + 3] = SYM2ID(e);
          }
        }
        n->nd_#{node_elem_name} = ALLOC_N(ID, len + 3);
        memcpy(n->nd_#{node_elem_name}, tmp_tbl, sizeof(ID) * (len + 3));
      }
      return;
      END
    when /\.(entry)$/
      puts <<-END
      n->nd_#{node_elem_name} = rb_global_entry(SYM2ID(v));
      return;
      END
    when /\.(cfunc)$/
      puts <<-END
      rb_raise(rb_eRuntimeError, "Cannot load #{$1}");
      END
    end
    puts <<-END
      }
    END
  end
  nil
END
  }
  rb_raise(rb_eRuntimeError, "Internal error: invalid Node_Elem_Name %d", nen);
}

#ruby <<END
  NODEINFO.sort.each do |node_elem_name, node_elem_ref|
    # get rid of warning about unused functions
    nen = node_elem_name.upcase
    next if NEN_TO_NODE_TYPE[nen].nil?

    if node_elem_name == "noex" or node_elem_name == "cflag" then
      # noex and cflag point to an id but are really a long
      node_elem_ref.sub!('id', 'cnt')
    end

    case node_elem_ref
    when /\.node$/, /\.value$/
      puts <<-END
/*
 * Return the Node's _#{node_elem_name}_ member.  The return type is
 * either a Node or an Object.
 */
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);

  if(TYPE(n->nd_#{node_elem_name}) == T_NODE)
  {
    return wrap_node((NODE *)n->nd_#{node_elem_name});
  }
  else
  {
    return (VALUE)n->nd_#{node_elem_name};
  }
}
      END
    when /\.id$/
      puts <<-END
/*
 * Return the Node's _#{node_elem_name}_ member.  The return type is a
 * Symbol.
 */
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  if(n->nd_#{node_elem_name} == 0)
  {
    rb_raise(
        rb_eRuntimeError,
        "Invalid ID for #{node_elem_name} (node type=%d)",
        nd_type(n));
  }
  return ID2SYM(n->nd_#{node_elem_name});
}
      END
    when /\.(argc|state|cnt)$/
      puts <<-END
/*
 * Return the Node's _#{node_elem_name}_ member.  The return type is an
 * Integer.
 */
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  return LONG2NUM(n->nd_#{node_elem_name});
}
      END
    when /\.(tbl)$/
      puts <<-END
/*
 * Return the Node's _#{node_elem_name}_ member.  The return value is an
 * Array holding names of variables.
 */
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  return variable_names(n->nd_#{node_elem_name});
}
      END
    when /\.(entry)$/
      puts <<-END
/*
 * Return the Node's _#{node_elem_name}_ member.  The return type is
 * either a Node or an Object.
 */
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  if(n->nd_#{node_elem_name}->id == 0)
  {
    rb_raise(
        rb_eRuntimeError,
        "Invalid ID for #{node_elem_name} (node type %d)",
        nd_type(n));
  }
  return ID2SYM(n->nd_#{node_elem_name}->id);
}
      END
    when /\.(cfunc)$/
      puts <<-END
/*
 * Return the Node's _#{node_elem_name}_ member.  The return type is an
 * integer representation of the #{node_elem_name}'s pointer.
 */
static VALUE node_#{node_elem_name}(VALUE self)
{
  NODE * n;
  Data_Get_Struct(self, NODE, n);
  return LONG2NUM((long)(n->nd_#{node_elem_name}));
}
      END
    end
  end
  nil
END

/*
 * Return an array of strings containing the names of the node class's
 * members.
 */
VALUE node_s_members(VALUE klass)
{
  return rb_iv_get(klass, "__member__");
}

void define_node_subclass_methods()
{
  /* For rdoc: rb_cNode = rb_define_class("Node", rb_cObject); */
  VALUE rb_cNode = rb_const_get(rb_cObject, rb_intern("Node"));
  VALUE members;

#ruby <<END
  NODE_TYPE_DESCRIPS.each do |descrip|
    case descrip.name
    when 'LAST'
      next
    when 'NIL', 'TRUE', 'FALSE'
      name = "#{descrip.name}NODE"
    else
      name = descrip.name
    end
    node_type = "rb_c#{name}"
    puts <<-END
  {
    VALUE #{node_type} = rb_define_class_under(rb_cNode, "#{name}", rb_cNode);
    members = rb_ary_new();
    rb_cNodeSubclass[NODE_#{descrip.name}] = #{node_type};
    rb_iv_set(#{node_type}, "__member__", members);
    rb_define_singleton_method(#{node_type}, "members", node_s_members, 0);
    END
    [descrip.node1, descrip.node2, descrip.node3].each do |nen|
      next if nen == 'NONE'
      nen = nen.downcase
      name = nen
      name = 'first' if nen == '1st'
      name = 'second' if nen == '2nd'
      puts <<-END
    rb_define_method(#{node_type}, "#{name}", node_#{nen}, 0);
    rb_ary_push(members, rb_str_new2("#{name}"));
      END
    end
    puts <<-END
  }
    END
  end
  nil
END
}


